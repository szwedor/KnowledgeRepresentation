\documentclass[11pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=2cm,includefoot,footskip=30pt]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{helvet}
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor}
\usepackage{pgfgantt}
\usepackage{parskip}
\usepackage[hidelinks]{hyperref}
\usepackage[polish]{babel}
\usepackage{float}
\usepackage{longtable}
\usepackage{graphicx,stackengine,scalerel}

\renewcommand{\familydefault}{\sfdefault}
\renewcommand{\arraystretch}{1.5}

\newtheorem{definition}{Definicja}[section]

\def\tang{\ThisStyle{\abovebaseline[0pt]{\scalebox{-1}{$\SavedStyle\perp$}}}}

\newcommand{\vapprox}{\mathrel{\scalebox{1}[2]{$\shortmid$}\mkern-3.1mu\raisebox{0.1ex}{$\approx$}}}

\begin{document}

    \begin{titlepage}
        \centering
        \includegraphics[width=\textwidth]{resources/WMiNI-znak-black.png} \par
        \vspace{3cm}
        {\LARGE Programy działań z efektami domyślnymi \par}
        \vspace{0.5cm}
        {\Large Reprezentacja Wiedzy - projekt \par}
        \vspace{2cm}
        {\large
            Bartosz Borkowicz\\
            Sebastian Konowrocki\\
            Tomasz Laskowski\\
            Piotr Łazarczyk\\
            Jakub Niemyjski\\
            Bartłomiej Pieńkowski\\
            Igor Pieńkowski\\
            Bartłomiej Teodorczuk\\
            Łukasz Wasilewski
        \par}
        \vspace{4cm}
        {\large Wersja 1.0 \par}
        \vspace{0.5cm}
        {\large \today \par}
    \end{titlepage}

    \tableofcontents
    \newpage

    \section{Opis zadania}
    
    Celem projektu jest opracowanie języka akcji oraz odpowiadającego mu języka kwerend dla klasy systemów dynamicznych, która została zdefiniowana poniżej.
    
    Język akcji ma być zaprojektowany dla klasy systemów dynamicznych spełniających następujące warunki:
    \begin{enumerate}
        \item Prawo inercji
        \item Niedeterminizm i sekwencyjność działań
        \item Pełna informacja o wszystkich akcjach i wszystkich skutkach bezpośrednich
        \item Z każdą akcją związany jest
            \begin{itemize}
                \item warunek początkowy (ew. $true$)
                \item efekt akcji
                \item jej wykonawca
            \end{itemize}
        \item Skutki akcji:
            \begin{itemize}
                \item \textit{pewne} - zawsze występują po zakończeniu akcji
                \item \textit{domyślne} - preferowane, zachodzą po zakończeniu akcji, o ile nie jest wiadomym, że nie występują
            \end{itemize}
        \item Efekty akcji zależą od stanu, w którym akcja się zaczyna oraz od jej wykonawcy
        \item W pewnych stanach akcje mogą być niewykonalne przez pewnych (wszystkich) wykonawców
    \end{enumerate}
    
    Język akcji spełniający dane warunki może być odpytywany poprzez odpowiadający mu język kwerend, który zapewnia uzyskanie odpowiedzi prawda ($true$) bądź fałsz ($false$) na następujące pytania:
    \begin{enumerate}
        \item Czy podany program działań jest wykonywalny zawsze/kiedykolwiek?
        \item Czy wykonanie podanego programu działań z dowolnego stanu spełniającego warunek $\pi$ prowadzi zawsze/kiedykolwiek/na ogół do stanu spełniającego warunek celu $\gamma$?
        \item Czy z dowolnego stanu spełniającego warunek $\pi$ cel $\gamma$ jest osiągany zawsze/kiedykolwiek/na ogół?
        \item Czy wskazany wykonawca jest zaangażowany w realizację programu zawsze/kiedykolwiek?
    \end{enumerate}
    
    \subsection{Oznaczenia}
        Na potrzeby uproszczenia definicji oraz opisów w dokumencie wykorzystywane są następujące oznaczenia:
    \begin{itemize}
        \item $A \in \mathcal{A}c$ - akcje
        \item $\omega \in \Omega$ - agenci, w szczególności $\epsilon$ oznacza brak agenta (jakiegokolwiek agenta)
        \item $f \in \mathcal{F}$ - fluenty
        \item $\bar{f}$ - literał odpowiadający $f$, czyli $f$ lub $\neg f$
        \item $\alpha, \pi \in Forms(\mathcal{F})$ - formuły
        \item $\sigma \in \Sigma$ - stany
    \end{itemize}
   
    Formułą nazywamy dowolne połączenie fluentów:
    
    $Forms(\mathcal{F}) \ni \alpha = f~|~\neg \alpha~|~\alpha_1 \wedge \alpha_2~|~\alpha_1 \vee \alpha_2~|~\alpha_1 \Rightarrow \alpha_2~|~\alpha_1 \Leftrightarrow \alpha_2$
    
    Dodatkowo istnieją specjalne formuły:
    \begin{itemize}
        \item $\tang$ oznaczający zawsze prawdę ($true$)
        \item $\perp$ oznaczający zawsze fałsz ($false$)
    \end{itemize}

    \section{Język akcji}
    \begin{definition}[Język $\mathcal{ADA}$]
        Język $\mathcal{ADA}$ jest językiem spełniającym założenia podane w opisie zadania. W poniższych sekcjach zostanie zdefiniowana jego sygnatura, syntaktyka oraz semantyka.
    \end{definition}

    \begin{definition}[Sygnatura]
        Sygnaturą języka $\mathcal{ADA}$ nazywamy parę $\Upsilon=(\mathcal{F},\mathcal{A}c)$, gdzie:
        \begin{itemize}
            \item $\mathcal{F}$ jest zbiorem fluentów
            \item $\mathcal{A}c$ jest zbiorem akcji
        \end{itemize}
    \end{definition}
    
    \subsection{Syntaktyka}
    
    Identyfikatorem jest nazwa akcji, agenta lub fluentu. Identyfikator składa się z ciągu dużych i małych liter alfabetu łacińskiego, cyfr oraz znaku podkreślenia (\_). Dodatkowo identyfikator nie może być żadnym ze słów kluczowych: \textbf{initially}, \textbf{always}, \textbf{observable}, \textbf{after}, \textbf{when}, \textbf{causes}, \textbf{impossible}, \textbf{typically}, \textbf{noninertial}, \textbf{if}, \textbf{not}, \textbf{and}, \textbf{or}, \textbf{then}, \textbf{iff}, \textbf{true}, \textbf{false}. W przypadku identyfikatorów wielkość liter ma znaczenie, to znaczy przykładowo akcje \textit{shoot} i \textit{Shoot} są dwiema różnymi akcjami.

    \subsubsection{Formuły}
    
    Poszczególnym operacjom z konstrukcji formuł odpowiadają następujące zapisy:
    \begin{itemize}
        \item $f \rightarrow identyfikator$ - nazwa fluentu, będąca identyfikatorem zgodnym z opisem powyżej,
        \item $\neg \alpha \rightarrow \mathbf{not}~\alpha$ - negacja logiczna formuły $\alpha$,
        \item $\alpha_1 \wedge \alpha_2 \rightarrow \alpha_1~\mathbf{and}~\alpha_2$ - koniunkcja logiczna formuł $\alpha_1$ i $\alpha_2$,
        \item $\alpha_1 \vee \alpha_2 \rightarrow \alpha_1~\mathbf{or}~\alpha_2$ - alternatywa logiczna formuł $\alpha_1$ i $\alpha_2$,
        \item $\alpha_1 \Rightarrow \alpha_2 \rightarrow \alpha_1~\mathbf{then}~\alpha_2$ - implikacja logiczna formuły $\alpha_1$ w $\alpha_2$,
        \item $\alpha_1 \Leftrightarrow \alpha_2 \rightarrow \alpha_1~\mathbf{iff}~\alpha_2$ - równoważność logiczna (\textit{if and only if}) formuł $\alpha_1$ i $\alpha_2$,
        \item $\tang \rightarrow \mathbf{true}$ - oznacza zawsze prawdę,
        \item $\perp \rightarrow \mathbf{false}$ - oznacza zawsze fałsz.
    \end{itemize}
    
    Dla wyżej wymienionych operacji została zdefiniowana następująca kolejność działań:
    \begin{enumerate}
        \item $\mathbf{not}$
        \item $\mathbf{and}$, $\mathbf{or}$
        \item $\mathbf{then}$
        \item $\mathbf{iff}$
    \end{enumerate}
   
    Nawiasy okrągłe \textit{()} mogą być użyte w celu grupowania wyrażeń oraz zmiany kolejności wykonywania działań matematycznych.
    
    \subsubsection{Instrukcja wartości}
    
    \begin{center}
        $\alpha~\mathbf{after}~\omega_1~A_1,...,\omega_n~A_n$
        \\gdzie $n \geq 1$
    \end{center}
    Formuła $\alpha$ jest \textbf{zawsze} prawdziwa po wykonaniu sekwencji akcji $A_1$ przez agenta $\omega_1$, $...$, $A_n$ przez agenta $\omega_n$. Podanie agenta wykonującego akcję nie jest wymagane. Jeżeli agent nie zostanie podany, wtedy akcja jest wykonywana przez kogokolwiek.
    
    \begin{center}
            $\mathbf{initially}~\alpha$
    \end{center}    
        Jeżeli dla powyższej instrukcji $n=0$, to musimy użyć skróconego zapisu. Oznacza on, że formuła $\alpha$ jest spełniona dla stanu początkowego.
                
    \begin{center}    
        $\mathbf{observable}~\alpha~\mathbf{after}~\omega_1~A_1,...,\omega_n~A_n$
        \\gdzie $n \geq 1$
    \end{center}
    Formuła $\alpha$ jest \textbf{czasem} prawdziwa po wykonaniu sekwencji akcji $A_1$ przez agenta $\omega_1$, $...$, $A_n$ przez agenta $\omega_n$. Podanie agenta wykonującego akcję nie jest wymagane. Jeżeli agent nie zostanie podany, wtedy akcja jest wykonywana przez kogokolwiek.
    
    \subsubsection{Instrukcja efektu}
    
    \begin{center}
        $\mathbf{when}~\omega_1~\mathbf{or}~...~\mathbf{or}~\omega_n~A~\mathbf{causes}~\alpha~\mathbf{if}~\pi$
        \\gdzie $n \geq 1$
    \end{center}
    Jeżeli akcja $A$ jest wywołana przez któregokolwiek z agentów $\omega_1, ..., \omega_n$ w stanie, który spełnia formułę $\pi$, stan wynikowy spełnia formułę $\alpha$.
    
    \begin{center}
        $\mathbf{when}~\omega_1~\mathbf{or}~...~\mathbf{or}~\omega_n~A~\mathbf{causes}~\alpha$
        \\gdzie $n \geq 1$
    \end{center}
    Zapis równoważny z powyższym, jeżeli $\pi \equiv \tang$. Jeżeli akcja $A$ jest wywołana przez któregokolwiek z agentów $\omega_1, ..., \omega_n$, stan wynikowy spełnia formułę $\alpha$.
    
    \begin{center}
        $A~\mathbf{causes}~\alpha~\mathbf{if}~\pi$    
    \end{center}
    Jeżeli akcja $A$ jest wywołana przez dowolnego agenta w stanie, który spełnia formułę $\pi$, stan wynikowy spełnia formułę $\alpha$. Jest to zapis pierwszej instrukcji, jeżeli akcja jest wywoływana przez dowolnego agenta.
    
    \begin{center}
        $A~\mathbf{causes}~\alpha$
    \end{center}
    Zapis równoważny z powyższym, jeżeli $\pi \equiv \tang$. Jeżeli akcja $A$ jest wywołana, stan wynikowy spełnia formułę $\alpha$.
    
    \begin{center}
        $\mathbf{impossible}~\omega_1~\mathbf{or}~...~\mathbf{or}~\omega_n~A~\mathbf{if}~\pi$
        \\gdzie $n \geq 1$
    \end{center}
    Zapis równoważny z pierwszym, jeżeli $\alpha \equiv \perp$. Akcja $A$ nie jest wykonywalna przez żadnego z agentów $\omega_1, ..., \omega_n$, w stanie, który spełnia formułę $\alpha$. 
    
    \begin{center}
        $\mathbf{impossible}~\omega_1~\mathbf{or}~...~\mathbf{or}~\omega_n~A$
        \\gdzie $n \geq 1$
    \end{center}
    Zapis równoważny z powyższym, jeżeli $\pi \equiv \tang$. Akcja $A$ nie jest wykonywalna przez żadnego z agentów $\omega_1, ..., \omega_n$.
    
    \begin{center}
        $\mathbf{impossible}~A~\mathbf{if}~\pi$
    \end{center}
    Akcja $A$ nie jest wykonywalna przez żadnego agenta w stanie, który spełnia formułę $\alpha$.
    
    \begin{center}
        $\mathbf{when}~\omega_1~\mathbf{or}~...~\mathbf{or}~\omega_n~A~\mathbf{typically~causes}~\alpha~\mathbf{if}~\pi$
        \\gdzie $n \geq 1$
    \end{center}
    Jeżeli akcja $A$ jest wywołana przez któregokolwiek z agentów $\omega_1, ..., \omega_n$ w stanie, który spełnia formułę $\pi$, stan wynikowy z reguły powinien spełniać formułę $\alpha$. Efekt $\alpha$ jest \textbf{preferowany} w odróżnieniu do efektów niedeterministycznych, gdzie żaden wynik nie jest preferowany.
    
    \begin{center}
        $\mathbf{when}~\omega_1~\mathbf{or}~...~\mathbf{or}~\omega_n~A~\mathbf{typically~causes}~\alpha$
        \\gdzie $n \geq 1$
    \end{center}
    Zapis równoważny z powyższym, jeżeli $\pi \equiv \tang$. Jeżeli akcja $A$ jest wywołana przez któregokolwiek z agentów $\omega_1, ..., \omega_n$, stan wynikowy z reguły powinien spełniać formułę $\alpha$.
    
    \begin{center}
        $A~\mathbf{typically~causes}~\alpha~\mathbf{if}~\pi$    
    \end{center}
    Jeżeli akcja $A$ jest wywołana przez dowolnego agenta w stanie, który spełnia formułę $\pi$, stan wynikowy powinien spełniać formułę $\alpha$.
    
    \begin{center}
        $A~\mathbf{typically~causes}~\alpha$
    \end{center}
    Zapis równoważny z powyższym, jeżeli $\pi \equiv \tang$. Jeżeli akcja $A$ jest wywołana, stan wynikowy powinien spełniać formułę $\alpha$.
    
    \subsubsection{Instrukcja uwolnienia}
    
    \begin{center}
        $\mathbf{when}~\omega_1~\mathbf{or}~...~\mathbf{or}~\omega_n~A~\mathbf{releases}~\bar{f}~\mathbf{if}~\pi$
    \end{center}
    Wykonanie akcji $A$ przez któregokolwiek agentów $\omega_1, ..., \omega_n$ w stanie, który spełnia warunek $\pi$ \textbf{może}, ale \textbf{nie musi} zmienić wartość inercyjnego fluentu $f$.
    
    \begin{center}
        $\mathbf{when}~\omega_1~\mathbf{or}~...~\mathbf{or}~\omega_n~A~\mathbf{releases}~\bar{f}$
    \end{center}
    Zapis równoważny z powyższym, jeżeli $\pi \equiv \tang$. Wykonanie akcji $A$ któregokolwiek agentów $\omega_1, ..., \omega_n$ \textbf{może}, ale \textbf{nie musi} zmienić wartość inercyjnego fluentu $f$.
    
    \begin{center}
        $A~\mathbf{releases}~\bar{f}~\mathbf{if}~\pi$
    \end{center}
    Wykonanie akcji $A$ przez dowolnego agenta w stanie, który spełnia warunek $\pi$ \textbf{może}, ale \textbf{nie musi} zmienić wartość inercyjnego fluentu $f$. Jest to zapis pierwszej instrukcji, jeżeli akcja jest wywoływana przez dowolnego agenta.
    
    \begin{center}
        $A~\mathbf{releases}~\bar{f}$
    \end{center}
    Zapis równoważny z powyższym, jeżeli $\pi \equiv \tang$. Wykonanie akcji $A$ \textbf{może}, ale \textbf{nie musi} zmienić wartość inercyjnego fluentu $f$.
    
    \subsubsection{Instrukcja ograniczenia}    
   
    \begin{center}
        $\mathbf{always}~\alpha$
    \end{center}
    Każdy stan musi spełniać formułę $\alpha$.
    
    \subsubsection{Instrukcja opisu fluentu}
    \begin{center}
        $\mathbf{noninertial}~f$
    \end{center}
    Oznaczenia fluentu $f$ jako nieinercjalnego.
    
    \subsection{Semantyka}
    
    \begin{definition}[Stan]
    Stanem nazywamy funkcję $\sigma: \mathcal{F} \rightarrow \{\tang, \perp\}$.
    Jeżeli $f \in \mathcal{F}$ i $\sigma(f)=\tang$ to zapisujemy $\sigma \models f$.
    Jeżeli $\alpha \in Forms(\mathcal{F})$ i formuła $\alpha$ jest prawdziwa w stanie $\sigma$ ($\sigma$ jest modelem $\alpha$), to zapisujemy $\sigma \models \alpha$.
    \end{definition}
    
    \begin{definition}[Dziedzina akcji]
    Dziedziną akcji $D$ nazywamy dowolny niepusty zbiór instrukcji.
    \end{definition}
    
    \begin{definition}[Semantyczna struktura interpretacyjna języka $\mathcal{ADA}$]
    Semantyczną strukturą interpretacyjną języka $\mathcal{ADA}$ nazywamy czwórkę $S=(\Sigma, \sigma_0, ResAb, ResN)$, gdzie:
    \begin{itemize}
        \item $\Sigma$ jest zbiorem stanów
        \item $\sigma_0 \in \Sigma$ jest stanem początkowym
        \item $ResAb: \mathcal{A}c \times \Omega \times \Sigma \rightarrow 2^\Sigma$ jest nietypową funkcją przejścia
        \item $ResN: \mathcal{A}c \times \Omega \times \Sigma \rightarrow 2^\Sigma$ jest typową funkcją przejścia
    \end{itemize}
    \end{definition}
    
    Niech $D$ będzie dziedziną akcji języka $\mathcal{ADA}$ i niech $S=(\Sigma, \sigma_0, ResAb, ResN)$ będzie jego strukturą. Stan $\sigma$ jest stanem dziedziny $D$ wtedy i tylko wtedy, gdy dla każdej instrukcji ograniczenia typu $\mathbf{always}~\alpha$ zachodzi $\sigma \models \alpha$ w danej dziedzinie $D$.
    
    Niech $Res = ResAb \cup ResN$, $\Psi_S: (\mathcal{A}c \times (\Omega \cup \{ \epsilon \}))^* \times \Sigma \rightarrow 2^\Sigma$ będzie mapowaniem takim, że:
    \begin{itemize}
        \item $\Psi_S(\epsilon, \sigma) = \sigma$
        \item jeśli $\Psi_s(((A_1, \omega_1), ..., (A_n, \omega_n), \sigma)$ jest zdefiniowany, to    
    \[
    \Psi_S(((A_1, \omega_1), ..., (A_n, \omega_n), \sigma) \in \left \{
        \begin{array}{ll}
             \bigcup\limits_{\omega \in \Omega} Res((A_n, \omega), \Psi_S((A_1, \omega_1), ..., (A_{n-1}, \omega_{n-1})),~jesli~\omega_n = \epsilon\\
             Res((A_n, \omega_n), \Psi_S((A_1, \omega_1), ..., (A_{n-1}, \omega_{n-1})),~w~p.p.
         \end{array}
     \right.
    \]
    \end{itemize}
    
    Instrukcja wartości typu $(\mathbf{observable})~\alpha~\mathbf{after}~\omega_1~A_1,...,\omega_n~A_n$ jest prawdziwa w $S$ wtedy i tylko wtedy, gdy dla (jakiegokolwiek) \textbf{każdego} mapowania $\Psi_S$
    \begin{itemize}
        \item $\Psi_s(((A_1, \omega_1), ..., (A_n, \omega_n), \sigma)$ jest zdefiniowane oraz 
        \item $\Psi_s(((A_1, \omega_1), ..., (A_n, \omega_n), \sigma) \models \alpha$
    \end{itemize}
    
    Wprowadźmy następujące oznaczenia:
    \begin{itemize}
        \item $New: \mathcal{A}c \times \Omega \times \Sigma \times \Sigma \rightarrow 2^{\bar{\mathcal{F}}}$ jest funkcją, która przypisuje każdej akcji $A \in \mathcal{A}c$, każdemu agentowi $\omega \in \Omega$ i wszystkim $\sigma, \sigma' \in \Sigma$ zbiór literałów $\bar{f}$ takich, że:
        \begin{itemize}
            \item $\sigma' \models \bar{f}$
            \item $f$ jest inercjalny oraz $\sigma \models f \neq \sigma' \models f$ lub\\
            dla jakiejś instrukcji prawdziwe jest $(\mathbf{when}~\omega~A~\mathbf{releases}~f~\mathbf{if}~\pi) \in D \vee (A~\mathbf{releases}~f~\mathbf{if}~\pi) \wedge \sigma \models \pi$
        \end{itemize}
        
        \item $Res_0: \mathcal{A}c \times \Omega \times \Sigma \rightarrow 2^\Sigma$ jest funkcją, która dla każdej akcji $A \in \mathcal{A}c$, każdego stanu $\sigma \in \Sigma$ i każdego agenta $\omega \in \Omega$ jest zbiorem wszystkich stanów $\sigma' \in \Sigma$ takich, że:\\
        $(\mathbf{when}~\omega~A~\mathbf{causes}~\alpha~\mathbf{if}~\pi) \in D \vee (A~\mathbf{causes}~\alpha~\mathbf{if}~\pi) \in D \wedge \sigma \models \pi \Rightarrow \sigma' \models \alpha$

        \item $Res^-: \mathcal{A}c \times \Omega \times \Sigma \rightarrow 2^\Sigma$ jest funkcją, która dla każdej akcji $A \in \mathcal{A}c$, każdego stanu $\sigma \in \Sigma$ i każdego agenta $\omega \in \Omega$ jest zbiorem wszystkich stanów $\sigma' \in \Sigma$ takich, że zbiory $New(A, \omega, \sigma, \sigma')$ są minimalne.
        
        \item $Res_0^+: \mathcal{A}c \times \Omega \times \Sigma \rightarrow 2^\Sigma$ jest funkcją, która dla każdej akcji $A \in \mathcal{A}c$, każdego stanu $\sigma \in \Sigma$ i każdego agenta $\omega \in \Omega$ jest zbiorem wszystkich stanów $\sigma' \in \Sigma$ takich, że:\\
        $(\mathbf{when}~\omega~A~\mathbf{typically~causes}~\alpha~\mathbf{if}~\pi) \in D \vee (A~\mathbf{typically~causes}~\alpha~\mathbf{if}~\pi) \in D \wedge \sigma \models \pi \Rightarrow \sigma' \models \alpha$
    \end{itemize}
    
    \begin{definition}[Model]
    Niech $D$ będzie dziedziną akcji języka $\mathcal{ADA}$. Struktura $S=(\Sigma, \sigma_0, ResAb, ResN)$ jest modelem $D$ wtedy i tylko wtedy, gdy:
    \begin{itemize}
        \item $\Sigma$ jest zbiorem wszystkich stanów dziedziny $D$
        \item wszystkie instrukcje wartości w $D$ są prawdziwe w $S$
        \item dla każdej akcji $A \in \mathcal{A}c$, każdego stanu $\sigma \in \Sigma$ i każdego agenta $\omega \in \Omega$
        \\$ResN(A,\omega,\sigma)=\{\sigma' \in Res_0^+(A,\omega,\sigma) \cup Res_0(A,\omega,\sigma):~ New(A,\omega,\sigma,\sigma')~jest~minimalny\}$
        \\$ResAb(A,\omega,\sigma)=Res^-(A,\omega,\sigma) \textbackslash ResN(A,\omega,\sigma)$
    \end{itemize}
    \end{definition}
    
    \begin{definition}[Program działań]
    Programem działań nazywamy ciąg $((A_1, \omega_1),...,(A_n,\omega_n))$, gdzie $A_i$ jest akcją, zaś $\omega_i$ jej wykonawcą lub $\epsilon$ (ktokolwiek). 
    \end{definition}
    
    \begin{definition}[Miara nietypowości]
    Dla każdej akcji $A \in \mathcal{A}c$, dowolnego wykonawcy $\omega$ i dowolnych dwóch stanów $\sigma$, $\sigma'$ $\in \Sigma$ definiujemy funkcję, zwaną miarą nietypowości: \\
    \[
    \kappa_S(A, \omega, \sigma, \sigma') = \left \{
        \begin{array}{ll}
             0,~jesli~\sigma' \in ResN(A, \omega, \sigma) \\
             1~jesli~\sigma' \in ResAb(A, \omega, \sigma) \\
             + \infty ~w.p.p.
         \end{array}
     \right.
    \]
    
    \end{definition}
    
    \begin{definition}[Zbiór $\Pi_S$]
    	Zdefiniujmy funkcję $K_{\Psi}$, taką że dla każdego mapowania $\Psi_S$ oraz dowolnego programu działań $((A_1, \omega_1),...,(A_n,\omega_n))$:
    	\begin{itemize}
    		\item $K_{\Psi}((A_1, \omega_1),...,(A_n,\omega_n)) = + \infty$, jeżeli $\Psi_S(((A_1, \omega_1),...,(A_n,\omega_n)), \sigma_0)$ jest zdefiniowane
    		\item $K_{\Psi}((A_1, \omega_1),...,(A_n,\omega_n)) = \sum_{i=1}^{n} \kappa_s(A_i, \sigma_{i-1}, \sigma_i)$, gdzie $\sigma_i = \Psi_S(A_i, \sigma_{i-1})$
    	\end{itemize}
    	
    	wtedy dla każdego programu działań $((A_1, \omega_1),...,(A_n,\omega_n))$, $\Pi_S((A_1, \omega_1),...,(A_n,\omega_n))$ jest zbiorem wszystkich mapowań $\Psi_S$, dla których $K_{\Psi}((A_1, \omega_1),...,(A_n,\omega_n))$ jest minimalne.
    \end{definition}
    
    \section{Język kwerend}
    
	Język akcji może być odpytywany przez zdefiniowany poniżej język kwerend. Wynikiem każdego z zapytań jest wartość $true$ oznaczająca prawdę lub $false$ oznaczająca fałsz.     
    
    \subsection{Syntaktyka}
    
    %\textbf{Uwaga:} Warunek $\mathbf{always}$ zachodzi, jeśli odpowiedź na kwerendę we \textbf{wszystkich} ścieżkach wykonania ma wartość $true$. Warunek $\mathbf{ever}$ zachodzi jeżeli istnieje co najmniej jedna taka ścieżka.
    
    \begin{center}
        $\mathbf{necessary}~\mathbf{executable}~((A_1, \omega_1),...,(A_n,\omega_n))$
    \end{center}
    
    Program działań $((A_1, \omega_1),...,(A_n,\omega_n))$ jest wykonywalny zawsze
    
    \begin{center}
        $\mathbf{possibly}~\mathbf{executable}~((A_1, \omega_1),...,(A_n,\omega_n))$
    \end{center}
    
    Program działań $((A_1, \omega_1),...,(A_n,\omega_n))$ jest wykonywalny kiedykolwiek.
    
    \begin{center}
        $\mathbf{necessary}~\gamma~\mathbf{after}~((A_1, \omega_1),...,(A_n,\omega_n))~\mathbf{from}~\pi$
    \end{center}
    
    Wykonanie programu działań $((A_1, \omega_1),...,(A_n,\omega_n))$ z dowolnego stanu spełniającego  warunek $\pi$ zawsze prowadzi do stanu spełniającego warunek $\gamma$.
    
    \begin{center}
        $\mathbf{possibly}~\gamma~\mathbf{after}~((A_1, \omega_1),...,(A_n,\omega_n))~\mathbf{from}~\pi$
    \end{center}
    
    Wykonanie programu działań $((A_1, \omega_1),...,(A_n,\omega_n))$ z dowolnego stanu spełniającego  warunek $\pi$ kiedykolwiek prowadzi do stanu spełniającego warunek $\gamma$.
    
    \begin{center}
        $\mathbf{typically}~\gamma~\mathbf{after}~((A_1, \omega_1),...,(A_n,\omega_n))~\mathbf{from}~\pi$
    \end{center}
    
    Wykonanie programu działań $((A_1, \omega_1),...,(A_n,\omega_n))$ z dowolnego stanu spełniającego  warunek $\pi$ na ogół prowadzi do stanu spełniającego warunek $\gamma$.
    
    \begin{center}
        $\mathbf{necessary}~\mathbf{accessible}~\gamma~\mathbf{from}~\pi$
    \end{center}
    
    Wykonanie dowolnego programu działań z dowolnego stanu spełniającego warunek $\pi$ zawsze prowadzi do stanu spełniającego warunek $\gamma$.
    
    \begin{center}
        $\mathbf{possibly}~\mathbf{accessible}~\gamma~\mathbf{from}~\pi$
    \end{center}
    
    Wykonanie dowolnego programu działań z dowolnego stanu spełniającego warunek $\pi$ kiedykolwiek prowadzi do stanu spełniającego warunek $\gamma$.
    
    
    \begin{center}
        $\mathbf{typically}~\mathbf{accessible}~\gamma~\mathbf{from}~\pi$
    \end{center}
    
    Wykonanie dowolnego programu działań z dowolnego stanu spełniającego warunek $\pi$ na ogół prowadzi do stanu spełniającego warunek $\gamma$.
    
    \begin{center}
        $\mathbf{necessary}~\omega~\mathbf{in}~((A_1, \omega_1),...,(A_n,\omega_n))$
    \end{center}
    
    Wykonawca $\omega$ jest zawsze zaangażowany w realizację programu działań $((A_1, \omega_1),...,(A_n,\omega_n))$.
    
    \begin{center}
        $\mathbf{possibly}~\omega~\mathbf{in}~((A_1, \omega_1),...,(A_n,\omega_n))$
    \end{center}
    
    Wykonawca $\omega$ jest kiedykolwiek zaangażowany w realizację programu działań $((A_1, \omega_1),...,(A_n,\omega_n))$.    
    
    \subsection{Semantyka}
    
    \begin{definition}[Konsekwencja]
    	Niech $D$ będzie dziedziną akcji języka $\mathcal{ADA}$. $Q$ jest konsekwencją $D$ (ozn. $D \vapprox Q$), wtedy i tylko wtedy kiedy:
    
    \begin{itemize}
    	\item jeżeli $Q$ jest postaci $\mathbf{necessary}~\mathbf{executable}~((A_1, \omega_1),...,(A_n,\omega_n))$: \\ dla każdej struktury $S=(\Sigma, \sigma_0, ResAb, ResN)$, będącej modelem $D$ oraz każdego mapowania $\Psi_S$, $\Psi_S(((A_1, \omega_1), ..., (A_n, \omega_n)), \sigma_0)$ jest zdefiniowane.
    	
    	\item jeżeli $Q$ jest postaci $\mathbf{possibly}~\mathbf{executable}~((A_1, \omega_1),...,(A_n,\omega_n))$: \\ dla każdej struktury $S=(\Sigma, \sigma_0, ResAb, ResN)$, będącej modelem $D$, istnieje mapowanie $\Psi_S$, takie że $\Psi_S(((A_1, \omega_1), ..., (A_n, \omega_n)), \sigma_0)$ jest zdefiniowane.
    	
    	\item jeżeli $Q$ jest postaci $\mathbf{necessary}~\gamma~\mathbf{after}~((A_1, \omega_1),...,(A_n,\omega_n))~\mathbf{from}~\pi$: \\
    	dla każdej struktury $S=(\Sigma, \sigma_0, ResAb, ResN)$, będącej modelem $D$, każdego stanu $\sigma \in \Sigma$ spełniającego warunek $\pi$ oraz każdego mapowania $\Psi_S$ zachodzi $\Psi_S(((A_1, \omega_1), ..., (A_n, \omega_n)), \sigma) \models \gamma$.
    	
    	\item jeżeli $Q$ jest postaci $\mathbf{possibly}~\gamma~\mathbf{after}~((A_1, \omega_1),...,(A_n,\omega_n))~\mathbf{from}~\pi$: \\
    	dla każdej struktury $S=(\Sigma, \sigma_0, ResAb, ResN)$, będącej modelem $D$, każdego stanu $\sigma \in \Sigma$ spełniającego warunek $\pi$ istnieje mapowanie $\Psi_S$, takie że zachodzi $\Psi_S(((A_1, \omega_1), ..., (A_n, \omega_n)), \sigma) \models \gamma$.
    	
    	\item jeżeli $Q$ jest postaci $\mathbf{typically}~\gamma~\mathbf{after}~((A_1, \omega_1),...,(A_n,\omega_n))~\mathbf{from}~\pi$: \\
    	dla każdej struktury $S=(\Sigma, \sigma_0, ResAb, ResN)$, będącej modelem $D$, każdego stanu $\sigma \in \Sigma$ spełniającego warunek $\pi$ oraz każdego mapowania $\Psi_S^{*} \in \Pi_S((A_1, \omega_1),...,(A_n,\omega_n))$ zachodzi $\Psi_S^{*}(((A_1, \omega_1), ..., (A_n, \omega_n)), \sigma) \models \gamma$.
    	
    	\item jeżeli $Q$ jest postaci $\mathbf{necessary}~\mathbf{accessible}~\gamma~\mathbf{from}~\pi$: \\
    	dla każdej struktury $S=(\Sigma, \sigma_0, ResAb, ResN)$, będącej modelem $D$, każdego stanu $\sigma \in \Sigma$ spełniającego warunek $\pi$ oraz każdego mapowania $\Psi_S$ istnieje program działań $((A_1, \omega_1), ..., (A_n, \omega_n))$, taki że $\Psi_S(((A_1, \omega_1), ..., (A_n, \omega_n)), \sigma) \models \gamma$.
    	
    	\item jeżeli $Q$ jest postaci $\mathbf{possibly}~\mathbf{accessible}~\gamma~\mathbf{from}~\pi$: \\
    	dla każdej struktury $S=(\Sigma, \sigma_0, ResAb, ResN)$, będącej modelem $D$, każdego stanu $\sigma \in \Sigma$ spełniającego warunek $\pi$, istnieje mapowanie $\Psi_S$, dla którego istnieje program działań $((A_1, \omega_1), ..., (A_n, \omega_n))$, taki że $\Psi_S(((A_1, \omega_1), ..., (A_n, \omega_n)), \sigma) \models \gamma$.
    	
    	\item jeżeli $Q$ jest postaci $\mathbf{typically}~\mathbf{accessible}~\gamma~\mathbf{from}~\pi$: \\
    	dla każdej struktury $S=(\Sigma, \sigma_0, ResAb, ResN)$, będącej modelem $D$, każdego stanu $\sigma \in \Sigma$ spełniającego warunek $\pi$ oraz każdego mapowania $\Psi_S^{*} \in \Pi_S((A_1, \omega_1),...,(A_n,\omega_n))$ istnieje program działań $((A_1, \omega_1), ..., (A_n, \omega_n))$, taki że $\Psi_S(((A_1, \omega_1), ..., (A_n, \omega_n)), \sigma) \models \gamma$.
    	
    	\item jeżeli $Q$ jest postaci $\mathbf{necessary}~\omega~\mathbf{in}~((A_1, \omega_1),...,(A_n,\omega_n))$: \\
    	 dla każdej struktury $S=(\Sigma, \sigma_0, ResAb, ResN)$, będącej modelem $D$ oraz każdego mapowania $\Psi_S$, $\Psi_S(((A_1, \omega_1), ..., (A_n, \omega_n)), \sigma_0)$ jest zdefiniowane oraz $\omega$ jest wykonawcą w jednym z elementów ciągu $((A_1, \omega_1),...,(A_n,\omega_n))$ lub istnieje element tego ciągu $(A_i, \epsilon),~1 \leq i \leq n$, taki że akcja $A_i$ jest wykonywalna \textbf{jedynie} przez wykonawcę $\omega$ w stanie otrzymanym po wykonaniu planu działania $((A_1, \omega_1),...,(A_{i-1},\omega_{i-1}))$ lub w stanie $\sigma_0$ jeżeli $i=1$.
    	 
    	 \item jeżeli $Q$ jest postaci $\mathbf{possibly}~\omega~\mathbf{in}~((A_1, \omega_1),...,(A_n,\omega_n))$: \\
    	 dla każdej struktury $S=(\Sigma, \sigma_0, ResAb, ResN)$, będącej modelem $D$, istnieje mapowanie $\Psi_S$, takie że $\Psi_S(((A_1, \omega_1), ..., (A_n, \omega_n)), \sigma_0)$ jest zdefiniowane oraz $\omega$ jest wykonawcą w jednym z elementów ciągu $((A_1, \omega_1),...,(A_n,\omega_n))$ lub istnieje element tego ciągu $(A_i, \epsilon),~1 \leq i \leq n$, taki że akcja $A_i$ jest wykonywalna przez wykonawcę $\omega$ w stanie otrzymanym po wykonaniu planu działania $((A_1, \omega_1),...,(A_{i-1},\omega_{i-1}))$ lub w stanie $\sigma_0$ jeżeli $i=1$.
    \end{itemize}
    \end{definition}
    
    \section{Przykład}
    
    Na arenie zamknięto dwóch niziołków: Bilba i Froda. Arenę jako żywy może opuścić tylko jeden. Na arenie znajduje się miecz. Frodo jest silny i młody a Bilbo stary i słaby. Frodo jest w stanie pokonać Bilba bez użycia miecza, a Bilbo Froda tylko przy użyciu broni. Bilbo słabo włada mieczem i może się okazać, że cios wyprowadzony przez niego bronią nie zabije przeciwnika. Zakładamy, że wrogowie, nie wyrywają sobie miecza nawzajem po podniesieniu go przez któregoś z nich.
    
    System dynamiczny opisujący powyższą sytuację posiada:
    \begin{itemize}
    \item zbiór agentów: $\Omega$ = \{Frodo, Bilbo\}
    \item zbiór akcji: $A_c$ = \{Take Sword, AttackFrodo, AttackBilbo\}
    \item zbiór fluentów: $\mathcal{F}$ = \{FrodoLives, BilboLives, FrodoHasSword, BilboHasSword\}
    \item zbiór stanów: $\Sigma$ = \{\\
    	$\sigma_0$ = \{FrodoLives, BilboLives, $\neg$FrodoHasSword, $\neg$BilboHasSword\},\\
    	$\sigma_1$ = \{FrodoLives, BilboLives, FrodoHasSword, $\neg$BilboHasSword\},\\
    	$\sigma_2$ = \{FrodoLives, BilboLives, $\neg$FrodoHasSword, BilboHasSword\},\\
    	$\sigma_3$ = \{$\neg$FrodoLives, BilboLives, $\neg$FrodoHasSword, BilboHasSword\},\\
    	$\sigma_4$ = \{FrodoLives, $\neg$BilboLives, FrodoHasSword, $\neg$BilboHasSword\},\\
    	$\sigma_5$ = \{FrodoLives, $\neg$BilboLives, $\neg$FrodoHasSword, $\neg$BilboHasSword\},\\
    	$\sigma_6$ = \{FrodoLives, $\neg$BilboLives, $\neg$FrodoHasSword, BilboHasSword\}\\
    \}.
    \end{itemize}
    Mamy następującą domenę akcji:
    
    \begin{center}
    $\mathbf{initially}$ FrodoLives $\mathbf{and}$ BilboLives $\mathbf{and}$ $\mathbf{not}$ FrodoHasSword $\mathbf{and}$ $\mathbf{not}$ BilboHasSword\\
    
    $\mathbf{when}$ Frodo TakeSword $\mathbf{causes}$ FrodoHasSword $\mathbf{if}$ $\mathbf{not}$ BilboHasSword\\
    
    $\mathbf{when}$ Bilbo TakeSword $\mathbf{causes}$ BilboHasSword $\mathbf{if}$ $\mathbf{not}$ FrodoHasSword\\
    
    $\mathbf{impossible}$ Frodo AttackFrodo\\
    
    $\mathbf{impossible}$ Bilbo AttackBilbo\\
    
    AttackFrodo $\mathbf{typically} ~ \mathbf{causes~not}$ FrodoLives $\mathbf{if}$ BilboHasSword\\
    
    AttackBilbo $\mathbf{causes~not}$ BilboLives $\mathbf{if}$ FrodoHasSword\\
    
    $\mathbf{observable~not}$ BilboLives $\mathbf{after}$ AttackBilbo\\ $\mathbf{if~not}$ FrodoHasSwordynh
    \includegraphics[width=\textwidth]{resources/graf.jpg} 
    \end{center}
 

\newpage
\subsection{Kwerendy}
Pytanie, na które szukamy odpowiedzi: \\
Czy Frodo zawsze atakuje Bilbo?\\
Postać kwerendy: \\
necessary executable {Frodo, AttacksBilbo} \\
Odpowiedź: \\
False \\

Pytanie, na które szukamy odpowiedzi: \\
Czy możliwe jest, że Frodo zaatakuje Bilbo, po tym jak Bilbo weźmie miecz i zaatakuje Froda?\\
Postać kwerendy: \\
possibly executable  ({Bilbo, TakeSword},{Bilbo,AttakFrodo},{Frodo,AttackBilbo})
Odpowiedź: \\
True\\

Pytanie, na które szukamy odpowiedzi: \\
Czy Bilbo zawsze umiera, jeśli Frodo weźmie miecz i zaatakuje Bilbo, zakładając że obaj żyją?\\
Postać kwerendy: \\
necessary $\neg$BilboLives after ({Frodo,TakeSword},{Frodo,AttackBilbo}) from BilboLives and FrodoLives  and $\neg$ FrodoHasSword \\
Odpowiedź: \\
False\\

Pytanie, na które szukamy odpowiedzi: \\
Czy Frodo na ogół umiera, jeśli Bilbo weźmie miecz i zaatakuje Frodo, zakładając że Bilbo i Frodo żyją, i Frodo nie ma miecza?\\
Postać kwerendy: \\
typically $\neg$FrodoLives after {Bilbo,TakeSword},{Bilbo, AttackFrodo}) from BilboLives and FrodoLives and $\neg$ FrodoHasSword \\
Odpowiedź: \\
True\\

Pytanie, na które szukamy odpowiedzi: \\
Czy Bilbo kiedykolwiek umiera, jeśli weźmie miecz, zaatakuje Frodo, po czym Frodo zaatakuje jego, jeśli na początku obaj żyją? \\
Postać kwerendy: \\
possibly $\neg$BilboLives
 after ({Bilbo,TakeSword},{Bilbo,AttackFrodo},{Frodo,AttackBilbo}) from BilboLives and FrodoLives \\
 Odpowiedź: \\
True

Pytanie, na które szukamy odpowiedzi: \\
Czy typowym jest osiągnięcie stanu, w którym Frodo żyje po wykonaniu pewnego programu w przypadku, gdy stan początkowy spełnia warunek, że Frodo żyje, a Bilbo ma miecz? \\ \\
Postać kwerendy: \\
typically accessible FrodoLives from FrodoLives, BilboHasSword \\ \\
Odpowiedź: \\
False 


\begin{table}[]
	\centering
	\label{my-label}
	\caption{$Róznice między stanami$}
\begin{longtable}{|p{1cm}|p{1.9cm}|p{1.9cm}|p{1.9cm}|p{1.9cm}|p{1.9cm}|p{1.9cm}|p{1.9cm}|}
\hline
     & $\sigma_0$  & $\sigma_1$ & $\sigma_2$ & $\sigma_3$ & $\sigma_4$ & $\sigma_5$ & $\sigma_6$ \\ \hline
	 $\sigma_0$ & $\emptyset$  & \{Frodo Has Sword\} & \{$\neg$Bilbo Lives, Frodo Has Sword\} & \{$\neg$Bilbo Lives, Frodo Has Sword\} & \{$\neg$Bilbo Lives, Frodo Has Sword\} & \{$\neg$Bilbo Lives\} & \{$\neg$Bilbo Lives, Bilbo Has Sword\} \\ \hline
	 
     $\sigma_1$ &  \{$\neg$Frodo Has Sword\} & $\emptyset$ & \{$\neg$Frodo Has Sword, Bilbo Has Sword\}  & \{$\neg$Frodo Lives, $\neg$Frodo Has Sword, Bilbo Has Sword\}  & \{$\neg$Bilbo Lives\} & \{$\neg$Bilbo Lives, $\neg$Frodo  Has Sword\} & \{$\neg$Bilbo Lives, $\neg$Frodo Has Sword, Bilbo Has Sword\}\\ \hline
     
     $\sigma_2$ &  \{Bilbo Lives, $\neg$Frodo Has Sword\}  & \{Frodo Has Sword, $\neg$Bilbo Has Sword\} & $\emptyset$ & \{$\neg$Frodo Lives\} & \{$\neg$Bilbo Lives, Frodo Has Sword, $\neg$Bilbo Has Sword\} & \{$\neg$Bilbo Lives, $\neg$Bilbo Has Sword\} & \{$\neg$Bilbo Lives\}\\ \hline
     
     $\sigma_3$ &  \{Frodo Lives, $\neg$Bilbo Has Sword\}  & \{Frodo Lives, Frodo Has Sword, $\neg$Bilbo Has Sword\} & \{Frodo Lives\} &  $\emptyset$ & \{Frodo Lives, $\neg$Bilbo Lives, Frodo Has Sword, $\neg$Bilbo Has Sword\} & \{Frodo Lives, $\neg$Bilbo Lives, $\neg$Bilbo Has Sword\} & \{Frodo Lives, $\neg$Bilbo Lives\} \\ \hline
     
     $\sigma_4$ &  \{Bilbo Lives, $\neg$Frodo Has Sword\}  & \{Bilbo Lives\} & \{Bilbo Lives, $\neg$Frodo Has Sword, Bilbo Has Sword\} & \{$\neg$Frodo Lives, Bilbo Lives, $\neg$Frodo Has Sword, Bilbo Has Sword\} & $\emptyset$ &\{$\neg$Frodo Has Sword\} & \{$\neg$Frodo Has Sword, Bilbo Has Sword\}  \\ \hline
     
     $\sigma_5$ &  \{Bilbo Lives\}  & \{Bilbo Lives, Frodo Has Sword\} & \{Bilbo Lives, Bilbo Has Sword\} & \{$\neg$Frodo Lives, Bilbo Lives, Bilbo Has Sword\} & \{Frodo Has Sword\} & $\emptyset$ & \{Bilbo Has Sword\} \\ \hline
     
     $\sigma_6$ &  \{Bilbo Lives, $\neg$Bilbo Has Sword\} & \{Bilbo Lives, Frodo Has Sword, $\neg$Bilbo Has Sword\} & \{Bilbo Lives\} & \{$\neg$Frodo Lives, Bilbo Lives\} & \{Frodo Has Sword, $\neg$Bilbo Has Sword\} & \{$\neg$Bilbo Has Sword\} & $\emptyset$\\ \hline
\end{longtable}
\end{table}
 
 
    \begin{table}[]
\centering
\label{my-label}
\caption{$Res_0,~ Res_0^+,~ ResAb,~ Res^-,~ ResN$}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
     &   & Frodo TakeSword & Bilbo TakeSword & AttackBilbo & AttackFrodo \\ \hline
$Res_0$ & $\sigma_0$ & $\left\{\sigma_1, \sigma_4\right\}$  & $\left\{\sigma_2, \sigma_3,\sigma_6\right\}$ & $\emptyset$ & $\emptyset$   \\ \hline
     & $\sigma_1$ &  $\left\{\sigma_1, \sigma_4\right\}$  & $\emptyset$ & $\left\{\sigma_4, \sigma_5,\sigma_6\right\}$  &  $\emptyset$  \\ \hline
     & $\sigma_2$ &  $\emptyset$  & $\left\{\sigma_2, \sigma_3,\sigma_6\right\}$ & $\emptyset$   &  $\left\{\sigma_3\right\}$ \\ \hline
     & $\sigma_3$ &  $\emptyset$  & $\left\{\sigma_2, \sigma_3,\sigma_6\right\}$ & $\emptyset$   &  $\left\{\sigma_3\right\}$ \\ \hline
     & $\sigma_4$ &  $\left\{\sigma_1, \sigma_4\right\}$  & $\emptyset$ & $\left\{\sigma_4, \sigma_5,\sigma_6\right\}$   &  $\emptyset$  \\ \hline
     & $\sigma_5$ &  $\left\{\sigma_1, \sigma_4\right\}$  & $\left\{\sigma_2, \sigma_3,\sigma_6\right\}$ & $\emptyset$   &  $\emptyset$  \\ \hline
     & $\sigma_6$ &  $\emptyset$  & $\left\{\sigma_2, \sigma_3,\sigma_6\right\}$ & $\emptyset$   &  $\left\{\sigma_3\right\}$  \\ \hline
$Res^-$ & $\sigma_0$ &  \{$\sigma_4$\} & \{$\sigma_3$, $\sigma_6$\} & $\emptyset$ & $\emptyset$   \\ \hline
     & $\sigma_1$ &  \{$\sigma_4$\}  & $\emptyset$ & \{$\sigma_6$\}   &  $\emptyset$  \\ \hline
     & $\sigma_2$ &  $\emptyset$  & \{$\sigma_3$, $\sigma_6$\} & $\emptyset$   &  \{$\sigma_3$\}  \\ \hline
     & $\sigma_3$ &  $\emptyset$  & \{$\sigma_6$\} & $\emptyset$   &  \{$\sigma_3$\} \\ \hline
     & $\sigma_4$ &  \{$\sigma_1$\}  & $\emptyset$ & \{$\sigma_6$\}   &  $\emptyset$  \\ \hline
     & $\sigma_5$ &  \{$\sigma_1$\}  & \{$\sigma_2$, $\sigma_3$\} & $\emptyset$   &  $\emptyset$  \\ \hline
     & $\sigma_6$ &  $\emptyset$  & \{$\sigma_3$\} & $\emptyset$   &  \{$\sigma_3$\} \\ \hline
$Res_0^+$ & $\sigma_0$ &  $\emptyset$ & $\emptyset$ & $\sigma_5$ & $\emptyset$   \\ \hline
     & $\sigma_1$ &  $\emptyset$  & $\emptyset$ & $\emptyset$   &  $\emptyset$  \\ \hline
     & $\sigma_2$ &  $\emptyset$  & $\emptyset$ & $\emptyset$   &  $\sigma_3$  \\ \hline
     & $\sigma_3$ &  $\emptyset$  & $\emptyset$ & $\emptyset$   &  $\emptyset$  \\ \hline
     & $\sigma_4$ &  $\emptyset$  & $\emptyset$ & $\emptyset$   &  $\emptyset$  \\ \hline
     & $\sigma_5$ &  $\emptyset$  & $\emptyset$ & $\emptyset$   &  $\emptyset$  \\ \hline
     & $\sigma_6$ &  $\emptyset$  & $\emptyset$ & $\emptyset$   &  $\emptyset$  \\ \hline
$ResN$ & $\sigma_0$ &  $\sigma_1$ & $\sigma_2$ & $\emptyset$ & $\emptyset$   \\ \hline
     & $\sigma_1$ &  $\emptyset$  & $\emptyset$ & $\sigma_4$   &  $\emptyset$  \\ \hline
     & $\sigma_2$ &  $\emptyset$  & $\emptyset$ & $\emptyset$   &  $\sigma_3$  \\ \hline
     & $\sigma_3$ &  $\emptyset$  & $\emptyset$ & $\emptyset$   &  $\emptyset$  \\ \hline
     & $\sigma_4$ &  $\emptyset$  & $\emptyset$ & $\emptyset$   &  $\emptyset$  \\ \hline
     & $\sigma_5$ &  $\emptyset$  & $\emptyset$ & $\emptyset$   &  $\emptyset$  \\ \hline
     & $\sigma_6$ &  $\emptyset$  & $\emptyset$ & $\emptyset$   &  $\emptyset$  \\ \hline
 $ResAb$ & $\sigma_0$ &  $\emptyset$ & $\emptyset$ & $\sigma_5$ & $\emptyset$   \\ \hline
     & $\sigma_1$ &  $\emptyset$  & $\emptyset$ & $\emptyset$   &  $\emptyset$  \\ \hline
     & $\sigma_2$ &  $\emptyset$  & $\emptyset$ & $\sigma_2,~\sigma_6$   &  $\sigma_6$  \\ \hline
     & $\sigma_3$ &  $\emptyset$  & $\emptyset$ & $\emptyset$   &  $\emptyset$  \\ \hline
     & $\sigma_4$ &  $\emptyset$  & $\emptyset$ & $\emptyset$   &  $\emptyset$  \\ \hline
     & $\sigma_5$ &  $\emptyset$  & $\emptyset$ & $\emptyset$   &  $\emptyset$  \\ \hline
     & $\sigma_6$ &  $\emptyset$  & $\emptyset$ & $\emptyset$   &  $\emptyset$  \\ \hline          
\end{tabular}
\end{table}




\end{document}